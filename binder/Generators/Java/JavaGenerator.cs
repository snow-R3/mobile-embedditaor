using System;
using System.Collections.Generic;
using System.Linq;
using CppSharp;
using CppSharp.AST;
using CppSharp.Generators;
using CppSharp.Passes;

using MonoEmbeddinator4000.Passes;

namespace MonoEmbeddinator4000.Generators
{
    public class JavaGenerator : Generator
    {
        public static string IntPtrType = "com.sun.jna.Pointer";

        public static string GetNativeLibPackageName(TranslationUnit unit) =>
            unit.FileName.Replace('.', '_').ToLowerInvariant();

        public JavaTypePrinter TypePrinter;

        public JavaGenerator(BindingContext context) : base(context)
        {
            TypePrinter = new JavaTypePrinter(Context);
        }

        List<CodeGenerator> Generators = new List<CodeGenerator>();

        public override List<CodeGenerator> Generate(IEnumerable<TranslationUnit> units)
        {
            // Java packages work very differently from C++/C# namespaces, so we take a
            // different approach. We generate a file for each declaration in the source.
            foreach (var unit in units)
            {
                GenerateDeclarationContext(unit);

                // Also generate a separate file with equivalent of P/Invoke declarations
                // for JNA.
                GenerateNativeDeclarations(unit);
            }

            return Generators;
        }

        public void GenerateNativeDeclarations(TranslationUnit unit)
        {
            // Since the native declarations are targetting the generated C bindings,
            // we need to modify the AST to match the one generated by the C target.

            var passes = new PassBuilder<TranslationUnitPass>(Context);
            CGenerator.SetupPasses(passes);

            Context.Options.GeneratorKind = GeneratorKind.C;

            passes.RunPasses(pass =>
            {
                pass.Context = Context;
                pass.VisitASTContext(Context.ASTContext);
            });

            Context.Options.GeneratorKind = GeneratorKind.Java;

            var nativeGen = new JavaNative(Context, unit);
            Generators.Add(nativeGen);
        }

        public void GenerateDeclarationContext(DeclarationContext context)
        {
            foreach (var decl in context.Declarations)
            {
                if (decl is Method || decl is Field || decl is Property ||
                    decl is TypedefDecl) continue;

                if (!(decl is Namespace))
                {
                    var sources = new JavaSources(Context, decl);
                    Generators.Add(sources);
                }

                if (decl is DeclarationContext)
                    GenerateDeclarationContext(decl as DeclarationContext);
            }
        }

        public override bool SetupPasses()
        {
            Context.TranslationUnitPasses.AddPass(new PropertyToGetterSetterPass());
            Context.TranslationUnitPasses.RenameDeclsLowerCase(
                RenameTargets.Function | RenameTargets.Method | RenameTargets.Property);
            return true;
        }

        protected override string TypePrinterDelegate(CppSharp.AST.Type type)
        {
            return type.Visit(TypePrinter).ToString();
        }
    }
}
